# ОТЧЕТ по 5-ему этапу.

В рамках данного этапа надо было перевести отправку запросов к соседним нодам
на подтверждение операции на асинхронный лад. Для этого была заменена обработка
в `handleRequest` на отправку запросов асинхронно к соседям, с передачей callback
который надо вызвать когда придет ответ или произойдет ошибка в ходе работы:

```java
private void handleAckRequest(Request request, String destinationUrl, ResponseAccumulator responseAccumulator) {
    try {
        HttpRequest javaRequest = ServiceUtils.createJavaRequest(request, destinationUrl);

        javaClients.get().get(destinationUrl)
                .sendAsync(javaRequest, HttpResponse.BodyHandlers.ofByteArray())
                .handleAsync((httpResponse, throwable) ->
                        handleSingleAcknowledgment(responseAccumulator, httpResponse, throwable),
                        internalRequestService
                );

    } catch (Exception e) {
        logger.error(e.getMessage());
        responseAccumulator.acknowledgeMissed();
    }
}
```

Для этого был разработан класс `ResponseAccumulator`, в котором собирается информация от поступающих
ответов. Очевидно, что мы не можем полагаться на какую-то последовательность вызовов,
так что надо как-то неблокирующим образом (иначе отличий от предыдущей версии не будет)
аккумулировать данные от запросов. Точнее нам надо так же как и раньше разграничивать
случай обработки гета, так как нам надо брать самый свежий ответ, и пут, где надо лишь
убедиться в количестве подтверждения. Потому я написал в этом аккумуляторе функцию, к которой у всех тредов есть доступ 
и которая локфри алгоритмом через `cas` обновляет данные о лучшем ответе, в случае гета, и в общем случае 
обновлять счётчик ответов и подтверждений.

```java
private void acknowledge(boolean success, Long time, Integer status, byte[] data) {
    if (success && method == Request.METHOD_GET) {
        Data newData = new Data(status, time, data);
        while (bestData.get().time < time) {
            Data curData = bestData.get();
            if (bestData.compareAndSet(curData, newData)) {
                break;
            }
        }
    }

    int curAck = acknowledged.incrementAndGet();

    answer(curAck);
}
```

Важно то, что нам принципиально лишь значение времени ответа, потому в вайл мы заходим только
если наше время лучше уже имеющегося, и пытаемся вписать свое значение. Заметим, что
мы всегда имеем прогресс, так как можно выстроить линейный порядок на времени ответов и если мы
выходим на "новый круг" цикла, то значит кто-то быстрее нас обновился, то есть максимум
количество нод раз мы зайдем в вайл. Да, алгоритм получается квадратичным в худшем случае, что
можно улучшить, например введя тред-сейф массив размера `from` и каждой ноде дать индекс.
Как наберется нужное количество, вызвать форсиком сбор и поиск лучшего ответа, в случае гета, или
просто закончить обработку иначе.

## Наблюдения при профилировании

### Настройка профилирования
Похожий скрипт `run5.sh` который по методу, числу тредов, числу конекшенов и значению RTS запускает
профилирование на двух нодах, запущенных перед этим, и нагружает в соответствие с параметрами
на протяжении минуту одну из нод.

Для гета отличие лишь в том, что сначала ноды набиваются данными последовательными путами
с большими кусками данных, как на диске окажется в районе 800Mb, начинаются запуски гетов.

### Наблюдения
В рамках профилирования обнаруживается 
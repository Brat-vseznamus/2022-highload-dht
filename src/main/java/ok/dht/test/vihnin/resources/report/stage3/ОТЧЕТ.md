# ОТЧЕТ по 3-ему этапу.

В рамках этого этапа мы должно были реализовать шардирование и
поддержку внутренних запросов.

Я реализовал `Consistent Hash` в рамках `ShardHelper`, который по входящему
айдишнику запроса получал шард, на котором лежат соответствующие ему данные.
Каждому серверу я выдавал по `VNODE_NUMBER_PER_SERVER` (в момент написания это 
число равно 5) виртуальных данных, таким образом распределяя разные интервалы
значений ключей равномерно по всем серверам.

Также в рамках этапа надо было выстроить связь между нодами, чтобы те могли
общаться в случае запросов, которые не относятся к потревоженной ноде, нода
могла оперативно спросить у ответственных и ответить за запрос.

Для этого в `ParallelHttpServer` появился `shardHelper`, который отвечал за
определение номера необходимой ноды, `internalRequestService` для выполнения
задач связи с другими нодами без отвлечения основного executor-а и `сlients`,
чтобы иметь сразу зарезервированные клиенты под общения с "коллегами", чтобы
не создавать их на каждый чих, раз всё равно у нас зафиксирована топология сети.

Давайте задумаеся над тем, а зачем нам отдельный обработчик для запросов
по внутренней? На этот имеется несколько причин: 

- Bо-первых, логически так корректнее,
так как у нас разделены вычисления разного типа.
- Во-вторых, общение с внутренней системой сильно дешевле по времени, так что
не стоит ухудшать средний отклик на запросы, которые обрабатываются только одной
нодой, запросами, которые могут быть сильно дольше из-за специфики внешнего мира, 
таких как стабильность сети, работоспособность других нод и тд. Также вероятно, что запросы
"насквозь" в реальности будут более редкими, так как оптимизации определения того, к кому будут
обращаться клиенты, могут быть на стороне фронта, что за почти бесплатно упрощает жизнь.

Также давайте подумаем над тем, а чем же такой подход (с шардированием) лучше нашей
предыдущей версии решения.
- Во-первых, мы делаем работу с сервисом проще, нам как администраторам, так
как выведение из строя части влечет меньшее количество проблем, чем централизованный вариант.
- Во-вторых, мы повышаем скорость обработки запросов, так как географически может приблизить
к клиентам наш сервис.
- В-третьих, мы разгружаем каждый сервис по отдельности, не только тем, что каждая нода ответственна
за меньшее количество данных, но и заменяя часть операция на ожидание сети, которое в принципе можно
оптимизировать и еще больше разгружать сервис, продлевая его срок службы.
